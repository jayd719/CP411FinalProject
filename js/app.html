<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Render 3D Cube with Enhanced Controls</title>
    <style>
        canvas { display: block; margin: auto; background: #E6E6E6; }
    </style>
</head>
<body>
<canvas id="webgl-cube" width="800" height="800"></canvas>

<script>
    const canvas = document.getElementById('webgl-cube');
    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

    if (!gl) {
        alert("WebGL not supported, please use a modern browser.");
        throw new Error("WebGL not supported");
    }

    // Vertex Shader
    const vertexShaderSource = `
        attribute vec3 aPosition;
        attribute vec3 aColor;
        uniform mat4 uModelViewMatrix;
        uniform mat4 uProjectionMatrix;
        varying vec3 vColor;

        void main() {
            gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aPosition, 1.0);
            vColor = aColor;
        }
    `;

    // Fragment Shader
    const fragmentShaderSource = `
        precision mediump float;
        varying vec3 vColor;

        void main() {
            gl_FragColor = vec4(vColor, 1.0);
        }
    `;

    // Compile Shader
    function compileShader(gl, sourceCode, type) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, sourceCode);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error(gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
            return null;
        }
        return shader;
    }

    // Initialize Shaders
    const vertexShader = compileShader(gl, vertexShaderSource, gl.VERTEX_SHADER);
    const fragmentShader = compileShader(gl, fragmentShaderSource, gl.FRAGMENT_SHADER);

    // Create Program
    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);

    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error(gl.getProgramInfoLog(program));
    }

    gl.useProgram(program);

    // Cube Data
    const cubeVertices = new Float32Array([
        // Front face
        -0.5, -0.5,  0.5,   1.0, 0.0, 0.0,
         0.5, -0.5,  0.5,   1.0, 0.0, 0.0,
         0.5,  0.5,  0.5,   1.0, 0.0, 0.0,
        -0.5,  0.5,  0.5,   1.0, 0.0, 0.0,

        // Back face
        -0.5, -0.5, -0.5,   0.0, 1.0, 0.0,
        -0.5,  0.5, -0.5,   0.0, 1.0, 0.0,
         0.5,  0.5, -0.5,   0.0, 1.0, 0.0,
         0.5, -0.5, -0.5,   0.0, 1.0, 0.0,

        // Left face
        -0.5, -0.5, -0.5,   0.0, 0.0, 1.0,
        -0.5, -0.5,  0.5,   0.0, 0.0, 1.0,
        -0.5,  0.5,  0.5,   0.0, 0.0, 1.0,
        -0.5,  0.5, -0.5,   0.0, 0.0, 1.0,

        // Right face
         0.5, -0.5, -0.5,   1.0, 1.0, 0.0,
         0.5,  0.5, -0.5,   1.0, 1.0, 0.0,
         0.5,  0.5,  0.5,   1.0, 1.0, 0.0,
         0.5, -0.5,  0.5,   1.0, 1.0, 0.0,

        // Top face
        -0.5,  0.5, -0.5,   1.0, 0.0, 1.0,
        -0.5,  0.5,  0.5,   1.0, 0.0, 1.0,
         0.5,  0.5,  0.5,   1.0, 0.0, 1.0,
         0.5,  0.5, -0.5,   1.0, 0.0, 1.0,

        // Bottom face
        -0.5, -0.5, -0.5,   0.0, 1.0, 1.0,
         0.5, -0.5, -0.5,   0.0, 1.0, 1.0,
         0.5, -0.5,  0.5,   0.0, 1.0, 1.0,
        -0.5, -0.5,  0.5,   0.0, 1.0, 1.0
    ]);

    const cubeIndices = new Uint16Array([
        0,  1,  2,  0,  2,  3,    // Front face
        4,  5,  6,  4,  6,  7,    // Back face
        8,  9, 10,  8, 10, 11,    // Left face
        12, 13, 14, 12, 14, 15,   // Right face
        16, 17, 18, 16, 18, 19,   // Top face
        20, 21, 22, 20, 22, 23    // Bottom face
    ]);

    // Create Buffer
    const vbo = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
    gl.bufferData(gl.ARRAY_BUFFER, cubeVertices, gl.STATIC_DRAW);

    const ibo = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, cubeIndices, gl.STATIC_DRAW);

    // Attributes
    const aPosition = gl.getAttribLocation(program, 'aPosition');
    const aColor = gl.getAttribLocation(program, 'aColor');

    gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 6 * Float32Array.BYTES_PER_ELEMENT, 0);
    gl.vertexAttribPointer(aColor, 3, gl.FLOAT, false, 6 * Float32Array.BYTES_PER_ELEMENT, 3 * Float32Array.BYTES_PER_ELEMENT);
    gl.enableVertexAttribArray(aPosition);
    gl.enableVertexAttribArray(aColor);

    // Matrices
    const uModelViewMatrix = gl.getUniformLocation(program, 'uModelViewMatrix');
    const uProjectionMatrix = gl.getUniformLocation(program, 'uProjectionMatrix');

    const modelViewMatrix = mat4.create();
    const projectionMatrix = mat4.create();

    mat4.perspective(projectionMatrix, Math.PI / 4, canvas.width / canvas.height, 0.1, 10);
    mat4.translate(modelViewMatrix, modelViewMatrix, [0, 0, -2]);

    gl.uniformMatrix4fv(uProjectionMatrix, false, projectionMatrix);

    let rotation = 0;

    function animate() {
        rotation += 0.01;
        mat4.rotate(modelViewMatrix, modelViewMatrix, rotation, [1, 1, 0]);
        gl.uniformMatrix4fv(uModelViewMatrix, false, modelViewMatrix);

        gl.clearColor(0.9, 0.9, 0.9, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        gl.drawElements(gl.TRIANGLES, cubeIndices.length, gl.UNSIGNED_SHORT, 0);

        requestAnimationFrame(animate);
    }

    gl.enable(gl.DEPTH_TEST);
    animate();
</script>
</body>
</html>
